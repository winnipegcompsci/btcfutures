var util = require('util'),
    _ = require('underscore'),
    request	= require('request'),
    crypto = require('crypto'),
    VError = require('verror'),
    md5 = require('MD5');

var BitMEX = function BitMEX(api_key, secret, server, timeout)
{
    this.api_key = api_key;
    this.secret = secret;

    this.server = server || 'https://testnet.bitmex.com:443';

    this.timeout = timeout || 20000;
};

var headers = {"User-Agent": "BitMEX Javascript API Client"};

BitMEX.prototype.getRequest = function(method, params, callback)
{
    var functionName = 'BitMEX.getRequest()',
        self = this;

    if(!this.api_key || !this.secret)
    {
        var error = new VError('%s must provide api_key and secret to make this API request.', functionName);
        return callback(error);
    }

    if(!_.isObject(params))
    {
        var error = new VError('%s second parameter %s must be an object. If no params then pass an empty object {}', functionName, params);
        return callback(error);
    }

    if (!callback || typeof(callback) != 'function')
    {
        var error = new VError('%s third parameter needs to be a callback function', functionName);
        return callback(error);
    }

    var nonce = new Date().getTime();
    var reqUrl = '/api/v1/' + method + '';
    
    headers = {
        "User-Agent": "BitMEX Javascript API Client",
        "api-nonce": nonce,
        "api-key": this.api_key,
        "api-signature": this.signMessage(params, reqUrl, nonce, this.secret, 'GET')
    };
    
    var options = {
        url: this.server + '/api/v1/' + method + '',
        method: 'GET',
        headers: headers,
        form: params
    };

    var requestDesc = util.format('%s request to url %s with method %s and params %s',
        options.method, options.url, method, JSON.stringify(params));
            
    executeRequest(options, requestDesc, callback);
};

BitMEX.prototype.postRequest = function(method, params, callback)
{
    var functionName = 'BitMEX.postRequest()',
        self = this;

    if(!this.api_key || !this.secret)
    {
        var error = new VError('%s must provide api_key and secret to make this API request.', functionName);
        return callback(error);
    }

    if(!_.isObject(params))
    {
        var error = new VError('%s second parameter %s must be an object. If no params then pass an empty object {}', functionName, params);
        return callback(error);
    }

    if (!callback || typeof(callback) != 'function')
    {
        var error = new VError('%s third parameter needs to be a callback function', functionName);
        return callback(error);
    }

    var nonce = new Date().getTime();
    var reqUrl = '/api/v1/' + method + '';
    
    headers = {
        "User-Agent": "BitMEX Javascript API Client",
        "api-nonce": nonce,
        "api-key": this.api_key,
        "api-signature": this.signMessage(params, reqUrl, nonce, this.secret, 'POST')
    };
    
    var options = {
        url: this.server + '/api/v1/' + method + '',
        method: 'POST',
        headers: headers,
        form: params
    };

    var requestDesc = util.format('%s request to url %s with method %s and params %s',
        options.method, options.url, method, JSON.stringify(params));
            
    executeRequest(options, requestDesc, callback);
};

BitMEX.prototype.putRequest = function(method, params, callback)
{
    var functionName = 'BitMEX.putRequest()',
        self = this;

    if(!this.api_key || !this.secret)
    {
        var error = new VError('%s must provide api_key and secret to make this API request.', functionName);
        return callback(error);
    }

    if(!_.isObject(params))
    {
        var error = new VError('%s second parameter %s must be an object. If no params then pass an empty object {}', functionName, params);
        return callback(error);
    }

    if (!callback || typeof(callback) != 'function')
    {
        var error = new VError('%s third parameter needs to be a callback function', functionName);
        return callback(error);
    }

    var nonce = new Date().getTime();
    var reqUrl = '/api/v1/' + method + '';
    
    headers = {
        "User-Agent": "BitMEX Javascript API Client",
        "api-nonce": nonce,
        "api-key": this.api_key,
        "api-signature": this.signMessage(params, reqUrl, nonce, this.secret, 'PUT')
    };
    
    var options = {
        url: this.server + '/api/v1/' + method + '',
        method: 'PUT',
        headers: headers,
        form: params
    };

    var requestDesc = util.format('%s request to url %s with method %s and params %s',
        options.method, options.url, method, JSON.stringify(params));
            
    executeRequest(options, requestDesc, callback);
};

BitMEX.prototype.deleteRequest = function(method, params, callback)
{
    var functionName = 'BitMEX.deleteRequest()',
        self = this;

    if(!this.api_key || !this.secret)
    {
        var error = new VError('%s must provide api_key and secret to make this API request.', functionName);
        return callback(error);
    }

    if(!_.isObject(params))
    {
        var error = new VError('%s second parameter %s must be an object. If no params then pass an empty object {}', functionName, params);
        return callback(error);
    }

    if (!callback || typeof(callback) != 'function')
    {
        var error = new VError('%s third parameter needs to be a callback function', functionName);
        return callback(error);
    }

    var nonce = new Date().getTime();
    var reqUrl = '/api/v1/' + method + '';
    
    headers = {
        "User-Agent": "BitMEX Javascript API Client",
        "api-nonce": nonce,
        "api-key": this.api_key,
        "api-signature": this.signMessage(params, reqUrl, nonce, this.secret, 'DELETE')
    };
    
    var options = {
        url: this.server + '/api/v1/' + method + '',
        method: 'DELETE',
        headers: headers,
        form: params
    };

    var requestDesc = util.format('%s request to url %s with method %s and params %s',
        options.method, options.url, method, JSON.stringify(params));
            
    executeRequest(options, requestDesc, callback);
};



/**
 * This method returns a signature for a request as a md5-encoded uppercase string
 * @param  {Object}  params   The object to encode
 * @return {String}           The request signature
 */
BitMEX.prototype.signMessage = function getMessageSignature(params, url, nonce, secret, verb)
{      
    var hmac = crypto.createHmac('sha256', secret);
    hmac.setEncoding('hex');
    
    var stringToSign = verb + url + nonce + JSON.stringify(params);
        
    hmac.write(stringToSign);
    hmac.end();   
    
    var result = hmac.read();
    
    // DEBUG ////////////
    // console.log("DEBUG::: \nParams: %s \nURL: %s \nnonce: %s \nSecret: %s \nVerb: %s\n",
        // util.inspect(params),
        // url,
        // nonce,
        // secret,
        // verb
    // );
    // console.log("DEBUG: Message: " + stringToSign);   
    // console.log("DEBUG: SIGNED MESSAGE: " + result);
    // END DEBUG ////////
    
    return result;
};

/**
 * This method returns the parameters as key=value pairs separated by & sorted by the key
 * @param  {Object}  params   The object to encode
 * @return {String}           formatted parameters
 */
function formatParameters(params)
{
    var sortedKeys = [],
        formattedParams = '';

    // sort the properties of the parameters
    sortedKeys = _.keys(params).sort();

    // create a string of key value pairs separated by '&' with '=' assignement
    for (i = 0; i < sortedKeys.length; i++)
    {
        if (i != 0) {
            formattedParams += '&';
        }
        formattedParams += sortedKeys[i] + '=' + params[sortedKeys[i]];
    }

    return formattedParams;
}

BitMEX.prototype.publicRequest = function(method, params, callback)
{
    var functionName = 'BitMEX.publicRequest()';

    if(!_.isObject(params))
    {
        var error = new VError('%s second parameter %s must be an object. If no params then pass an empty object {}', functionName, params);
        return callback(error);
    }

    if (!callback || typeof(callback) != 'function')
    {
        var error = new VError('%s third parameter needs to be a callback function with err and data parameters', functionName);
        return callback(error);
    }

    var url = this.server + '/api/v1/' + method + '';

    var options = {
        url: url,
        method: 'GET',
        headers: headers,
        timeout: this.timeout,
        qs: params,
        json: {}        // request will parse the json response into an object
    };

    var requestDesc = util.format('%s request to url %s with parameters %s',
        options.method, options.url, JSON.stringify(params));

    executeRequest(options, requestDesc, callback)
};

function executeRequest(options, requestDesc, callback)
{
    var functionName = 'BitMEX.executeRequest()';

    request(options, function(err, response, data)
    {
        var error = null,   // default to no errors
            returnObject = data;

        if(err)
        {
            error = new VError(err, '%s failed %s', functionName, requestDesc);
            error.name = err.code;
        }
        else if (response.statusCode < 200 || response.statusCode >= 300)
        {
            error = new VError('%s HTTP status code %s returned from %s', functionName,
                response.statusCode, requestDesc);
            error.name = response.statusCode;
        }
        else if (options.form)
        {
            try {
                returnObject = JSON.parse(data);
            }
            catch(e) {
                error = new VError(e, 'Could not parse response from server: ' + data);
            }
        }
        // if json request was not able to parse json response into an object
        else if (options.json && !_.isObject(data) )
        {
            error = new VError('%s could not parse response from %s\nResponse: %s', functionName, requestDesc, data);
        }

        if (_.has(returnObject, 'error_code'))
        {
            var errorMessage = mapErrorMessage(returnObject.error_code);

            error = new VError('%s %s returned error code %s, message: "%s"', functionName,
                requestDesc, returnObject.error_code, errorMessage);

            error.name = returnObject.error_code;
        }

        callback(error, returnObject);
    });
}

//
// Public Functions
//

BitMEX.prototype.getIndices = function getIndices(callback, symbol)
{
    this.publicRequest('instrument/indices', {}, callback);
};

BitMEX.prototype.getActiveIndices = function getActiveIndices(callback, symbol) 
{
    this.publicRequest('instrument/active', {}, callback);
};

//
// Private Functions
//

BitMEX.prototype.getOrders = function getOrders(callback, symbol, filter, columns, count, start, reverse, startTime, endTime)
{
    var params = {};
    if(symbol) params.symbol = symbol;
    if(filter) params.filter = filter;
    if(columns) params.columns = columns;
    if(count) params.count = count;
    if(start) params.start = start;
    if(reverse) params.reverse = reverse;
    if(startTime) params.startTime = startTime;
    if(endTime) params.endTime = endTime;
    
    this.getRequest('order', params, callback);
};

BitMEX.prototype.getTrades = function getTrades(callback, symbol, filter, columns, count, start, reverse, startTime, endTime)
{
    var params = {};
    if(symbol) params.symbol = symbol;
    if(filter) params.filter = filter;
    if(columns) params.columns = columns;
    if(count) params.count = count;
    if(start) params.start = start;
    if(reverse) params.reverse = reverse;
    if(startTime) params.startTime = startTime;
    if(endTime) params.endTime = endTime;
    
    this.getRequest('trade', params, callback);
};

BitMEX.prototype.placeOrder = function placeOrder(callback, symbol, quantity, price, ioc, type, stopPrice, clOrdID) 
{
    var params = {};
    if(symbol) params.symbol = symbol;
    if(quantity) params.quantity = quantity;
    if(price) params.price = price;
    if(ioc) params.ioc = ioc;
    if(type) params.type = type;
    if(stopPrice) params.stopPrice = stopPrice;
    if(clOrdID) params.clOrdID = clOrdID;
    
    this.postRequest('order', params, callback);
};

BitMEX.prototype.cancelOrder = function cancelOrder(callback, orderID, clOrdID, text)
{
    var params = {};
    if(orderID) params.orderId = orderID;
    if(clOrdID) params.clOrdID = clOrdID;
    if(text) params.text = text;
    
    this.deleteRequest('order', params, callback);
};


BitMEX.prototype.getTradeHistory = function getTradeHistory(callback, symbol, filter, columns, count, start, reverse, startTime, endTime)
{
    var params = {};
    if(symbol) params.symbol = symbol;
    if(filter) params.filter = filter;
    if(columns) params.columns = columns;
    if(count) params.count = count;
    if(start) params.start = start;
    if(reverse) params.reverse = reverse;
    if(startTime) params.startTime = startTime;
    if(endTime) params.endTime = endTime;
    
    this.getRequest('execution/tradeHistory', params, callback);  
};

BitMEX.prototype.getPositions = function getPositions(callback, filter, columns, count) 
{
    var params = {};
    
    if(filter) params.filter = filter;
    if(columns) params.columns = columns;
    if(count) params.count = count;
    
    this.getRequest('position', params, callback);
};

module.exports = BitMEX;