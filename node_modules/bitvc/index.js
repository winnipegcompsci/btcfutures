var util = require('util'),
    _ = require('underscore'),
    request	= require('request'),
    crypto = require('crypto'),
    VError = require('verror'),
    md5 = require('MD5');

var BitVC = function BitVC(api_key, secret, server, timeout)
{
    this.api_key = api_key;
    this.secret = secret;

    this.server = server || '';

    this.timeout = timeout || 20000;
};

var headers = {"User-Agent": "BitVC Javascript API Client"};

BitVC.prototype.privateRequest = function(method, params, callback)
{
    var functionName = 'BitVC.privateRequest()',
        self = this;

    if(!this.api_key || !this.secret)
    {
        var error = new VError('%s must provide api_key and secret to make this API request.', functionName);
        return callback(error);
    }

    if(!_.isObject(params))
    {
        var error = new VError('%s second parameter %s must be an object. If no params then pass an empty object {}', functionName, params);
        return callback(error);
    }

    if (!callback || typeof(callback) != 'function')
    {
        var error = new VError('%s third parameter needs to be a callback function', functionName);
        return callback(error);
    }

    params.api_key = this.api_key;
    params.sign = this.signMessage(params);

    var options = {
        url: method,
        method: 'POST',
        headers: headers,
        form: params
    };

    var requestDesc = util.format('%s request to url %s with method %s and params %s',
        options.method, options.url, method, JSON.stringify(params));

    executeRequest(options, requestDesc, callback);
};

/**
 * This method returns a signature for a request as a md5-encoded uppercase string
 * @param  {Object}  params   The object to encode
 * @return {String}           The request signature
 */
BitVC.prototype.signMessage = function getMessageSignature(params)
{
    var formattedParams = formatParameters(params);

    // append secret key value pair
    formattedParams += '&secret_key=' + this.secret;

    return md5(formattedParams).toUpperCase();
};

/**
 * This method returns the parameters as key=value pairs separated by & sorted by the key
 * @param  {Object}  params   The object to encode
 * @return {String}           formatted parameters
 */
function formatParameters(params)
{
    var sortedKeys = [],
        formattedParams = '';

    // sort the properties of the parameters
    sortedKeys = _.keys(params).sort();

    // create a string of key value pairs separated by '&' with '=' assignement
    for (i = 0; i < sortedKeys.length; i++)
    {
        if (i != 0) {
            formattedParams += '&';
        }
        formattedParams += sortedKeys[i] + '=' + params[sortedKeys[i]];
    }

    return formattedParams;
}

BitVC.prototype.publicRequest = function(method, params, callback)
{
    var functionName = 'BitVC.publicRequest()';

    if(!_.isObject(params))
    {
        var error = new VError('%s second parameter %s must be an object. If no params then pass an empty object {}', functionName, params);
        return callback(error);
    }

    if (!callback || typeof(callback) != 'function')
    {
        var error = new VError('%s third parameter needs to be a callback function with err and data parameters', functionName);
        return callback(error);
    }

    var url = method;

    var options = {
        url: url,
        method: 'GET',
        headers: headers,
        timeout: this.timeout,
        qs: params,
        json: {}        // request will parse the json response into an object
    };

    var requestDesc = util.format('%s request to url %s with parameters %s',
        options.method, options.url, JSON.stringify(params));

    executeRequest(options, requestDesc, callback)
};

function executeRequest(options, requestDesc, callback)
{
    var functionName = 'BitVC.executeRequest()';

    request(options, function(err, response, data)
    {
        var error = null,   // default to no errors
            returnObject = data;

        if(err)
        {
            error = new VError(err, '%s failed %s', functionName, requestDesc);
            error.name = err.code;
        }
        else if (response.statusCode < 200 || response.statusCode >= 300)
        {
            error = new VError('%s HTTP status code %s returned from %s', functionName,
                response.statusCode, requestDesc);
            error.name = response.statusCode;
        }
        else if (options.form)
        {
            try {
                returnObject = JSON.parse(data);
            }
            catch(e) {
                error = new VError(e, 'Could not parse response from server: ' + data);
            }
        }
        // if json request was not able to parse json response into an object
        else if (options.json && !_.isObject(data) )
        {
            error = new VError('%s could not parse response from %s\nResponse: %s', functionName, requestDesc, data);
        }

        if (_.has(returnObject, 'error_code'))
        {
            var errorMessage = mapErrorMessage(returnObject.error_code);

            error = new VError('%s %s returned error code %s, message: "%s"', functionName,
                requestDesc, returnObject.error_code, errorMessage);

            error.name = returnObject.error_code;
        }

        callback(error, returnObject);
    });
}

//
// Public Functions
//

BitVC.prototype.getTicker = function getTicker(callback)
{
    this.publicRequest(
        'http://market.bitvc.com/futures/ticker_btc_quarter.js', 
        {}, 
        callback
    );
};

BitVC.prototype.getFutureTicker = function getFutureTicker(callback) 
{
    this.publicRequest(
        'http://market.bitvc.com/futures/ticker_btc_quarter.js',
        {},
        callback
    );
}

BitVC.prototype.getExchangeRate = function getExchangeRate(callback) {
    this.publicRequest(
        'http://market.bitvc.com/futures/exchange_rate.js',
        {},
        callback
    );
}

BitVC.prototype.getCurrentOrders = function getCurrentOrders(callback) {
    this.privateRequest(
        'https://api.bitvc.com/api/order/list',
        {},
        callback
    );
}

BitVC.prototype.getDepth = function getDepth(callback, symbol, size, merge)
{
    var params = {
        symbol: symbol,
        size: 200,
        merge: 1
    };

    if (!_.isUndefined(size) ) params.size = size;
    if (!_.isUndefined(merge) ) params.merge = merge;

    this.publicRequest('depth', params, callback);
};

BitVC.prototype.getFutureDepth = function getFutureDepth(callback, symbol, contract_type, size, merge)
{
    var params = {};
    if(symbol) params.symbol = symbol;
    if(contract_type) params.contract_type = contract_type;
    if(size) params.size = size;
    if(merge) params.merge = merge;
    
    this.publicRequest('future_depth', params, callback);
};

BitVC.prototype.getTrades = function getTrades(callback, symbol, since)
{
    var params = {symbol: symbol};
    if (since) params.since = since;

    this.publicRequest('trades', params, callback);
};

BitVC.prototype.getFutureTrades = function getFutureTrades(callback, symbol, contract_type)
{
    var params = {symbol: symbol};
    if (contract_type) {
        params.contract_type = contract_type;
    }
        
    this.publicRequest('future_trades', params, callback);
};

BitVC.prototype.getKline = function getKline(callback, symbol, type, size, since)
{
    var params = {symbol: symbol};
    if (type) params.type = type;
    if (size) params.size = size;
    if (since) params.since = since;

    this.publicRequest('kline', params, callback);
};

BitVC.prototype.getFutureKline = function getFutureKline(callback, symbol, type, contract_type, size, since) 
{
    var params = {symbol: symbol};
    if(type) params.type = type;
    if(contract_type) params.contract_type = contract_type;
    if(size) params.size = size;
    if(since) params.since = since;
    
    this.publicRequest('future_kline', params, callback);
}


BitVC.prototype.getLendDepth = function getLendDepth(callback, symbol)
{
    this.publicRequest('kline', {symbol: symbol}, callback);
};

//
// Private Functions
//

BitVC.prototype.getUserBalance = function getUserBalance(callback) 
{
    this.privateRequest('futures/balance', {}, callback); 
};

BitVC.prototype.getUserPositions = function getUserPositions(callback)
{
    this.privateRequest('futures/holdOrder/list', {}, callback);
};

BitVC.prototype.getUserPositionSummary = function  getUserPositionSummary(callback)
{
    this.privateRequest('futures/holdOrder', {}, callback);
};

BitVC.prototype.getAllCurrentOrders = function getAllCurrentOrders(callback)
{
    this.privateRequest('futures/order/list', {}, callback);
};

BitVC.prototype.getOrderDetails = function getOrderDetails(callback, coinType, contractType, created, id) {
    var params = {};
    if(coinType) params.coinType = coinType;
    if(contractType) params.contractType = contractType;
    if(created) params.created = created;
    if(id) params.id = id;
    
    this.privateRequest('futures/order', params, callback);
};

BitVC.prototype.placeOrder = function placeOrder(callback, coinType, contractType, created, orderType, tradeType, price, money, leverage, tradePassword, storeId)
{
    var params = {};
    if(coinType) params.coinType = coinType;
    if(contractType) params.contractType = contractType;
    if(created) params.created = created;
    if(orderType) params.orderType = orderType;
    if(tradeType) params.tradeType = tradeType;
    if(price) params.price = price;
    if(money) params.money = money;
    if(leverage) params.leverage = leverage;
    if(tradePassword) params.tradePassword = tradePassword;
    if(storeId) params.storeId = storeId;
    
    this.privateRequest('futures/order/save', params, callback);
    
};

BitVC.prototype.cancelOrder = function cancelOrder(callback, coinType, contractType, created, id) 
{
    var params = {};
    if(coinType) params.coinType = coinType;
    if(contractType) params.contractType = contractType;
    if(created) params.created = created;
    if(id) params.id = id;
    
    this.privateRequest('futures/order/cancel', params, callback);
};

BitVC.prototype.systemCloseOrder = function systemCloseOrder(callback, coinType, contractType, created)
{
    var params = {};
    if(coinType) params.coinType = coinType;
    if(contractType) params.contractType = contractType;
    if(created) params.created = created;
    
    this.privateRequest('futures/systemCloseOrder/list', params, callback);
}


/**
 * Maps the BitVC error codes to error message
 * @param  {Integer}  error_code   BitVC error code
 * @return {String}                error message
 */
function mapErrorMessage(error_code)
{
    var errorCodes = {
        0: 'Success',
        1: 'Server Error',
        2: 'The system is in the settlement and delivery status, can not carry out operation',
        18: 'Money Password Error',
        26: 'Order Does Not Exist',
        32: 'Balance Insufficient',
        33: 'Close Amount Cannot be Larger than open Amount',
        34: 'Account Liquidation ongoing, cannot perform this operation',
        41: 'Order has already been canceled',
        42: 'Order has been completed, cannot cancel',
        43: 'Order Error, please contact customer support',
        45: 'Order price cannot be greater than limit',
        46: 'Order price cannot be less than limit',
        47: 'Order price cannot be greater than Maximum CNY',
        48: 'Order price cannot be greater than Minimum CNY',
        63: 'Please use POST request',
        64: 'Invalid request parameter value',
        65: 'Request lacks required parameter',
        66: 'Request message not supplied',
        67: 'Private Key Verification Failed',
        68: 'Invalid Price',
        69: 'Invalid amount',
        70: 'Invalid Request Time',
        71: 'Too many requests',
        72: 'Invalid order type',
        73: 'Invalid transaction type',
        74: 'Invalid contract type',
        75: 'Invalid currency',
        97: 'Please enter money password',
        110: 'Order price cannot exceed',
        111: 'Order amount must be a multiple of 100'
    };

    if (!errorCodes[error_code])
    {
        return 'Unknown BitVC error code: ' + error_code;
    }

    return( errorCodes[error_code] );
}

module.exports = BitVC;